/**
 * ExploitDB Sync Script (Ground Truth Generator)
 *
 * This script fetches the 'files_exploits.csv' from ExploitDB, identifies
 * all CVEs that have a confirmed exploit, and then pulls their descriptions
 * from the 'vulnerabilities' table (populated by sync_nvd.js).
 *
 * Finally, it upserts these confirmed exploits into the 'exploits' table
 * with Exploitability = 1. This table serves as the "Ground Truth"
 * for training the ExBERT model.
 */

import { createClient } from '@supabase/supabase-js';
import 'dotenv/config';
import fetch from 'node-fetch';
import { parse } from 'csv-parse/sync';

// --- Configuration ---

const CSV_URL = 'https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv';

// Supabase config
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_KEY; // FIX: Changed from SUPABASE_KEY
if (!supabaseUrl || !supabaseKey) {
  console.error('::FATAL:: Missing SUPABASE_URL or SUPABASE_SERVICE_KEY environment variables.');
  process.exit(1);
}
const supabase = createClient(supabaseUrl, supabaseKey);

// SCHEMA FIX: Use user's table names
const NVD_TABLE = 'vulnerabilities'; // Source of descriptions
const EXPLOIT_TABLE = 'exploits';    // Destination table (Ground Truth)
const CHUNK_SIZE = 500; // Chunk size for querying and upserting

// --- Main Execution ---

async function main() {
  console.log('::INFO:: Starting ExploitDB sync (Ground Truth generation)...');
  try {
    // 1. Fetch and parse ExploitDB CSV
    const csvData = await fetchCSV();
    const exploitRecords = parseCSV(csvData);

    // 2. Get unique CVE IDs from ExploitDB
    const cveIdsWithExploits = getUniqueCveIds(exploitRecords);
    console.log(`::INFO:: Found ${cveIdsWithExploits.length} unique CVE IDs in ExploitDB.`);

    // 3. Fetch descriptions for these CVEs from our NVD table
    console.log(`::INFO:: Fetching descriptions from '${NVD_TABLE}' table...`);
    const groundTruthData = await fetchDescriptionsForCVEs(cveIdsWithExploits);
    console.log(`::INFO:: Found ${groundTruthData.length} matching entries in '${NVD_TABLE}'.`);

    // 4. Batch upsert this ground truth data into the 'exploits' table
    await batchUpsertGroundTruth(groundTruthData);

    console.log(`::INFO:: ExploitDB Ground Truth Sync completed successfully.`);

  } catch (error) {
    console.error(`::FATAL:: An error occurred during ExploitDB sync: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Fetches the CSV data from ExploitDB.
 */
async function fetchCSV() {
  try {
    console.log(`::INFO:: Fetching CSV from ${CSV_URL}...`);
    const response = await fetch(CSV_URL);
    if (!response.ok) {
      throw new Error(`Failed to fetch CSV: ${response.status} ${response.statusText}`);
    }
    return await response.text();
  } catch (error) {
    console.error('::ERROR:: Failed to download ExploitDB data.', error);
    throw error;
  }
}

/**
 * Parses the raw CSV text.
 */
function parseCSV(csvData) {
  try {
    console.log('::INFO:: Parsing CSV data...');
    const records = parse(csvData, {
      columns: true,
      skip_empty_lines: true,
    });
    return records;
  } catch (error) {
    console.error('::ERROR:: Failed to parse CSV.', error);
    throw error;
  }
}

/**
 * Extracts a unique set of CVE IDs from the ExploitDB records.
 */
function getUniqueCveIds(records) {
  const cveSet = new Set();
  for (const record of records) {
    // Extract the first CVE ID if multiple exist
    const cveId = record.codes?.split(',')[0].trim();
    if (cveId && cveId.startsWith('CVE-')) {
      cveSet.add(cveId);
    }
  }
  return Array.from(cveSet);
}

/**
 * Queries the 'vulnerabilities' table to get descriptions for the CVEs
 * that are known to have an exploit.
 * @param {Array<string>} cveIds - List of CVE IDs from ExploitDB.
 * @returns {Array<object>} Array of objects ready for the 'exploits' table.
 */
async function fetchDescriptionsForCVEs(cveIds) {
  const results = [];
  for (let i = 0; i < cveIds.length; i += CHUNK_SIZE) {
    const chunk = cveIds.slice(i, i + CHUNK_SIZE);

    const { data, error } = await supabase
      .from(NVD_TABLE)
      .select('ID, text') // Select ID and description (text)
      .in('ID', chunk);

    if (error) {
      console.warn(`::WARN:: Error fetching descriptions for chunk: ${error.message}`);
      continue;
    }

    if (data) {
      // 6. Format for 'exploits' table
      const transformed = data.map(vulnerability => ({
        ID: vulnerability.ID,
        Description: vulnerability.text,
        Exploitability: 1 // This is the ground truth label
      }));
      results.push(...transformed);
    }
  }
  return results;
}

/**
 * Upserts the ground truth data in batches into the 'exploits' table.
 * @param {Array<object>} data - Array of { ID, Description, Exploitability: 1 }
 */
async function batchUpsertGroundTruth(data) {
  console.log(`::INFO:: Starting batch upsert to '${EXPLOIT_TABLE}'...`);
  for (let i = 0; i < data.length; i += CHUNK_SIZE) {
    const chunk = data.slice(i, i + CHUNK_SIZE);

    const { error } = await supabase
      .from(EXPLOIT_TABLE)
      .upsert(chunk, { onConflict: 'ID' }); // On conflict, update

    if (error) {
      console.error(`::ERROR:: Failed to upsert data chunk (Index ${i}):`, error.message);
    } else {
      console.log(`::INFO:: Successfully upserted chunk ${Math.floor(i / CHUNK_SIZE) + 1}/${Math.ceil(data.length / CHUNK_SIZE)}...`);
    }
  }
}

// --- Start the script ---

main();
