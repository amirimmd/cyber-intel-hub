// مسیر فایل: scripts/sync_exploitdb.js
import { createClient } from '@supabase/supabase-js';
import fetch from 'node-fetch';
import 'dotenv/config'; // برای بارگیری متغیرها از .env در اجرای محلی

// URL منبع داده ExploitDB
const EXPLOITDB_CSV_URL = 'https://raw.githubusercontent.com/offensive-security/exploitdb/main/files_exploits.csv';

// دریافت متغیرهای محیطی
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('::ERROR:: SUPABASE_URL or SUPABASE_SERVICE_KEY is not set.');
  process.exit(1);
}

// مقداردهی اولیه Supabase Client با Service Key
// این اسکریپت در سرور اجرا می‌شود، بنابراین به Service Key نیاز دارد
const supabase = createClient(supabaseUrl, supabaseServiceKey);

/**
 * یک ردیف CSV را تجزیه می‌کند.
 * این یک پارسر ساده است و ممکن است برای موارد پیچیده نیاز به بهبود داشته باشد.
 */
function parseCsvRow(row) {
  // این یک پارسر CSV بسیار ساده است که فرض می‌کند کاما (,) در داخل مقادیر وجود ندارد
  return row.split(',');
}

/**
 * داده‌های CSV ExploitDB را واکشی و پردازش می‌کند
 */
async function syncExploitDB() {
  console.log('::INFO:: Starting ExploitDB sync...');
  
  try {
    // 1. واکشی داده‌های CSV
    console.log(`::INFO:: Fetching data from ${EXPLOITDB_CSV_URL}...`);
    const response = await fetch(EXPLOITDB_CSV_URL);
    if (!response.ok) {
      throw new Error(`Failed to fetch CSV: ${response.statusText}`);
    }
    const csvData = await response.text();
    
    // 2. پردازش داده‌های CSV
    const rows = csvData.split('\n');
    const header = rows.shift().split(','); // دریافت هدر: id,file,description,date_published,author,type,platform,port

    console.log(`::INFO:: Found ${rows.length} exploits. Processing...`);

    const exploitsToInsert = [];
    for (const row of rows) {
      if (!row) continue; // نادیده گرفتن ردیف‌های خالی
      
      const values = parseCsvRow(row);
      if (values.length < 7) continue; // نادیده گرفتن ردیف‌های ناقص

      // نگاشت ستون‌های CSV به ستون‌های دیتابیس شما
      // بر اساس کامپوننت React، شما به: id, date, title, type, platform, author, url نیاز دارید
      const exploitId = values[0];
      const filePath = values[1];
      const description = values[2];
      const datePublished = values[3];
      const author = values[4];
      const type = values[5];
      const platform = values[6];

      // ساخت URL برای ExploitDB
      const exploitUrl = `https://www.exploit-db.com/exploits/${exploitId}`;

      exploitsToInsert.push({
        id: parseInt(exploitId, 10), // ستون 'id' شما باید از نوع عددی باشد
        title: description,
        date: datePublished,
        author: author,
        type: type,
        platform: platform,
        url: exploitUrl,
        // سایر فیلدها مانند file_path را در صورت نیاز اضافه کنید
        // file_path: filePath
      });
    }

    // 3. درج داده‌ها در Supabase
    // ما فقط 100 اکسپلویت آخر را برای جلوگیری از بار زیاد درج می‌کنیم
    // شما می‌توانید این محدودیت را بردارید یا منطق صفحه‌بندی (Pagination) اضافه کنید
    const latestExploits = exploitsToInsert.slice(-100); 
    
    console.log(`::INFO:: Upserting ${latestExploits.length} latest exploits into Supabase...`);
    
    // از 'upsert' استفاده می‌کنیم تا در صورت وجود 'id' رکوردهای تکراری ایجاد نشود
    const { error } = await supabase
      .from('exploits') // نام جدول شما
      .upsert(latestExploits, { onConflict: 'id' }); // 'id' باید کلید اصلی (Primary Key) باشد

    if (error) {
      console.error('::ERROR:: Supabase upsert failed:', error);
      throw error;
    }

    console.log('::SUCCESS:: ExploitDB sync completed successfully.');
    
  } catch (error) {
    console.error('::FATAL:: An error occurred during ExploitDB sync:', error.message);
    process.exit(1);
  }
}

// اجرای اسکریپت
syncExploitDB();

